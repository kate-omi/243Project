volatile int start_mouse; // shows which key was last pressed
volatile int count;
unsigned char seg7[] = {0x3f, 0x06, 0x5b, 0x4f, 0x66, 0x6d, 0x7d, 0x07, 0x7f, 0x67};
volatile int *HEX3_HEX0_ptr = (int *)0xFF200020;    
int i;
int j;
#include <stdlib.h>
#include <string.h>
#include <time.h>
#define PS2_BASE 0xFF200100
#define HEX3_HEX0_BASE 0xFF200020
#define HEX5_HEX4_BASE 0xFF200030
#define SW 0xFF200040
#define MOUSEHEIGHT 4
#define MOUSEWIDTH 4
volatile int pixel_buffer_start; // global variable
short int Buffer1[640][480]; // Adjusted to 320 columns for clarity, assuming no padding is needed for this example
short int Buffer2[640][480];
volatile int *pixel_ctrl_ptr = (int *)0xFF203020; // Control register for the pixel buffer
int buffernum =0;
int pixelData[640][480][2];
int ctr=0;
struct PIT_t {
      volatile unsigned int      DR;
      volatile unsigned int      DIR;
      volatile unsigned int      MASK;
      volatile unsigned int      EDGE;
      };
struct PIT_t *const swp = ((struct PIT_t *)0xFF200040);

int mouseClearX [2][MOUSEWIDTH];
int mouseClearY [2][MOUSEHEIGHT];


#ifndef __NIOS2_CTRL_REG_MACROS__
#define __NIOS2_CTRL_REG_MACROS__
/*****************************************************************************/
/* Macros for accessing the control registers. */
/*****************************************************************************/
#define NIOS2_READ_STATUS(dest) \
do { dest = __builtin_rdctl(0); } while (0)
#define NIOS2_WRITE_STATUS(src) \
do { __builtin_wrctl(0, src); } while (0)
#define NIOS2_READ_ESTATUS(dest) \
do { dest = __builtin_rdctl(1); } while (0)
#define NIOS2_READ_BSTATUS(dest) \
do { dest = __builtin_rdctl(2); } while (0)
#define NIOS2_READ_IENABLE(dest) \
do { dest = __builtin_rdctl(3); } while (0)
#define NIOS2_WRITE_IENABLE(src) \
do { __builtin_wrctl(3, src); } while (0)
#define NIOS2_READ_IPENDING(dest) \
do { dest = __builtin_rdctl(4); } while (0)
#define NIOS2_READ_CPUID(dest) \
do { dest = __builtin_rdctl(5); } while (0)
#endif

/* function prototypes */
void interrupt_handler(void);
void interval_timer_isr(void);
void pushbutton_ISR(void);
void plot_pixel(int x, int y, short int line_color);
void clear_screen();
void wait_for_vsync();
void HEX_PS2(char, char, char);
void clearpixel(int x, int y);
/* The assembly language code below handles Nios II reset processing */
void the_reset (void) __attribute__ ((section (".reset")));
void the_reset (void)
/*******************************************************************************
* Reset code; by using the section attribute with the name ".reset" we allow the linker program
* to locate this code at the proper reset vector address. This code just calls the main program
******************************************************************************/
{
asm (".set noat"); // magic, for the C compiler
asm (".set nobreak"); // magic, for the C compiler
asm ("movia r2, main"); // call the C language main program
asm ("jmp r2");
}
/* The assembly language code below handles Nios II exception processing. This code should not be
* modified; instead, the C language code in the function interrupt_handler() can be modified as
* needed for a given application. */
void the_exception (void) __attribute__ ((section (".exceptions")));
void the_exception (void)
/*******************************************************************************
* Exceptions code; by giving the code a section attribute with the name ".exceptions" we allow
* the linker to locate this code at the proper exceptions vector address. This code calls the
* interrupt handler and later returns from the exception.
******************************************************************************/
{
asm (".set noat"); // magic, for the C compiler
asm (".set nobreak"); // magic, for the C compiler
asm ( "subi sp, sp, 128");
asm ( "stw et, 96(sp)");
asm ( "rdctl et, ctl4");
asm ( "beq et, r0, SKIP_EA_DEC"); // interrupt is not external
asm ( "subi ea, ea, 4"); // must decrement ea by one instruction for externa
asm ( "SKIP_EA_DEC:" );
asm ( "stw r1, 4(sp)" ); // save all registers
asm ( "stw r2, 8(sp)" );
asm ( "stw r3, 12(sp)" );
asm ( "stw r4, 16(sp)" );
asm ( "stw r5, 20(sp)" );
asm ( "stw r6, 24(sp)" );
asm ( "stw r7, 28(sp)" );
asm ( "stw r8, 32(sp)" );
asm ( "stw r9, 36(sp)" );
asm ( "stw r10, 40(sp)" );
asm ( "stw r11, 44(sp)" );
asm ( "stw r12, 48(sp)" );
asm ( "stw r13, 52(sp)" );
asm ( "stw r14, 56(sp)" );
asm ( "stw r15, 60(sp)" );
asm ( "stw r16, 64(sp)" );
asm ( "stw r17, 68(sp)" );
asm ( "stw r18, 72(sp)" );
asm ( "stw r19, 76(sp)" );
asm ( "stw r20, 80(sp)" );
asm ( "stw r21, 84(sp)" );
asm ( "stw r22, 88(sp)" );
asm ( "stw r23, 92(sp)" );
asm ( "stw r25, 100(sp)" ); // r25 = bt (skip r24 = et, because it was saved above)
asm ( "stw r26, 104(sp)" ); // r26 = gp
// skip r27 because it is sp, and there is no point in saving this
asm ( "stw r28, 112(sp)" ); // r28 = fp
asm ( "stw r29, 116(sp)" ); // r29 = ea
asm ( "stw r30, 120(sp)" ); // r30 = ba
asm ( "stw r31, 124(sp)" ); // r31 = ra
asm ( "addi fp, sp, 128" );
asm ( "call interrupt_handler" ); // call the C language interrupt handler
asm ( "ldw r1, 4(sp)" ); // restore all registers
asm ( "ldw r2, 8(sp)" );
asm ( "ldw r3, 12(sp)" );
asm ( "ldw r4, 16(sp)" );
asm ( "ldw r5, 20(sp)" );
asm ( "ldw r6, 24(sp)" );
asm ( "ldw r7, 28(sp)" );
asm ( "ldw r8, 32(sp)" );
asm ( "ldw r9, 36(sp)" );
asm ( "ldw r10, 40(sp)" );
asm ( "ldw r11, 44(sp)" );
asm ( "ldw r12, 48(sp)" );
asm ( "ldw r13, 52(sp)" );
asm ( "ldw r14, 56(sp)" );
asm ( "ldw r15, 60(sp)" );
asm ( "ldw r16, 64(sp)" );
asm ( "ldw r17, 68(sp)" );
asm ( "ldw r18, 72(sp)" );
asm ( "ldw r19, 76(sp)" );
asm ( "ldw r20, 80(sp)" );
asm ( "ldw r21, 84(sp)" );
asm ( "ldw r22, 88(sp)" );
asm ( "ldw r23, 92(sp)" );
asm ( "ldw r24, 96(sp)" );
asm ( "ldw r25, 100(sp)" ); // r25 = bt
asm ( "ldw r26, 104(sp)" ); // r26 = gp
// skip r27 because it is sp, and we did not save this on the stack
asm ( "ldw r28, 112(sp)" ); // r28 = fp
asm ( "ldw r29, 116(sp)" ); // r29 = ea
asm ( "ldw r30, 120(sp)" ); // r30 = ba
asm ( "ldw r31, 124(sp)" ); // r31 = ra
asm ( "addi sp, sp, 128" );
asm ( "eret" );
}
/********************************************************************************
* Interrupt Service Routine: Determines the interrupt source and calls the appropriate subroutine
*******************************************************************************/
void interrupt_handler(void){
int ipending;
NIOS2_READ_IPENDING(ipending);
	if ( ipending & 0x1 ) // interval timer is interrupt level 0
	interval_timer_isr( );
	// else, ignore the interrupt
	return;
}
/********************************************************************************
* Interval timer interrupt service routine
* Shifts a pattern being displayed on the HEX displays. The shift direction is determined
* by the external variable key_pressed.
********************************************************************************/
void interval_timer_isr() {
    volatile int *interval_timer_ptr = (int *)0xFF202000; // interval timer base address
    *interval_timer_ptr = 0;                                // clear the interrupt

    // If KEY0 is pressed and count is greater than 0, decrement count
    if (start_mouse==1 && count > 0) {
        count--;
        // Update HEX displays with current value of count
        *HEX3_HEX0_ptr = (seg7[count % 10] | seg7[count / 10] << 8);
    }

    // If count reaches 0, stop decrementing and clear key_pressed
    if (count == 0) {
        start_mouse = 0;
    }
}
/********************************************************************************
********************************************************************************/
int main(void)
{
start_mouse=1;
i=10;
j=2;
count = 30;
*HEX3_HEX0_ptr = (seg7[0] | seg7[3] << 8);
/* Declare volatile pointers to I/O registers (volatile means that IO load and store instructions
* will be used to access these pointer locations instead of regular memory loads and stores) */
volatile int * interval_timer_ptr = (int *) 0xFF202000; // interval timer base address
/* set the interval timer period for scrolling the HEX displays */
int counter = 100000000; //1sec
*(interval_timer_ptr + 0x2) = (counter & 0xFFFF);
*(interval_timer_ptr + 0x3) = (counter >> 16) & 0xFFFF;
/* start interval timer, enable its interrupts */
*(interval_timer_ptr + 1) = 0x7; // STOP = 0, START = 1, CONT = 1, ITO = 1


	for(int i=0; i<MOUSEWIDTH; i++){
		mouseClearX [0][i]=-1;
		mouseClearX [1][i]=-1;
	}
		
	for (int j = 0; j < MOUSEHEIGHT; j++) {
		mouseClearY [0][j]=-1;
		mouseClearY [1][j]=-1;

	}
    volatile int *PS2_ptr = (int *)PS2_BASE;
    int PS2_data, RVALID;
    char byte1 = 0, byte2 = 0, byte3 = 0;
    // PS/2 mouse reset
    *(PS2_ptr) = 0xFF;
    int dx = 100;
	int dy = 100; 
	
	// Set front pixel buffer to Buffer 1
    volatile int *pixel_ctrl_ptr = (int *)0xFF203020;
    *(pixel_ctrl_ptr + 1) = (int)&Buffer1;

    // Swap buffers to set the front buffer location
    wait_for_vsync();
    pixel_buffer_start = *pixel_ctrl_ptr;
	    clear_screen();


    // Set back pixel buffer to Buffer 2
    *(pixel_ctrl_ptr + 1) = (int)&Buffer2;
    pixel_buffer_start = *(pixel_ctrl_ptr + 1);
	    clear_screen();

    
    while (1) {
		NIOS2_WRITE_IENABLE( 0x3 ); /* set interrupt mask bits for levels 0 (interval timer)
		* and level 1 (pushbuttons) */
		NIOS2_WRITE_STATUS( 1 ); // enable Nios II interrupts
        PS2_data = *PS2_ptr;
        RVALID = PS2_data & 0x8000;//anding it with bit 15 to see if data avilable to read
		if (RVALID) {
            byte1 = byte2;
            byte2 = byte3;
            byte3 = PS2_data & 0xFF;
			if(ctr<3){
				ctr++;
					}
				else{
					ctr=1;
				}
			}
		if(ctr==3){
         dx += byte1; 
         dy -= byte2;

         //does not always show the mouse, no erase function

			if (dx < 0) dx = 0;
            if (dx > 319 - MOUSEWIDTH) dx = 319 - MOUSEWIDTH;
            if (dy < 0) dy = 0;
            if (dy > 239 - MOUSEHEIGHT) dy = 239 - MOUSEHEIGHT;
		
			if((swp->DR & 0b01) == 1){
				for (int x = 0; x < MOUSEWIDTH; x++) {
					for (int y = 0; y < MOUSEHEIGHT; y++) {
						plot_pixel(dx + x, dy + y, 0xFFFF); // Draw pixel in white
						pixelData[dx + x][dy + y][buffernum] = 0xFFFF; // Store the pixel data
        			}
    			}
			}
           else if ((swp->DR & 0b10) == 1){
		   	for(int i=0; i< MOUSEWIDTH && mouseClearX[buffernum][i]!=-1; i++){
				for(int j=0; j< MOUSEHEIGHT && mouseClearY[buffernum][j]!=-1; j++){
					clearpixel(mouseClearX[buffernum][i],mouseClearY[buffernum][j]);
				}
			}
			for (int x = 0; x < MOUSEWIDTH; x++) {
				for (int y = 0; y < MOUSEHEIGHT; y++) {
					plot_pixel(dx + x, dy + y, 0xFFFF); // Draw pixel in white
					if (x == 0) {
						mouseClearY[buffernum][y] = dy + y;
					}
				}
				mouseClearX[buffernum][x] = dx + x;
				//going to have to change this to new colour
			}
		   }

			
			else {
    // Clear previously drawn pixels
    			for (int i = 0; i < MOUSEWIDTH && mouseClearX[buffernum][i] != -1; i++) {
        			for (int j = 0; j < MOUSEHEIGHT && mouseClearY[buffernum][j] != -1; j++) {
            		// Check if there is something drawn at this pixel's location
            		if (pixelData[i][j][buffernum] == 0) {
                		clearpixel(mouseClearX[buffernum][i],mouseClearY[buffernum][j]);
            		}
        		}
    		}

    			// Draw the mouse
				for (int x = 0; x < MOUSEWIDTH; x++) {
					for (int y = 0; y < MOUSEHEIGHT; y++) {
						// Draw only if there's nothing drawn at this pixel's location
						if (pixelData[dx + x][dy + y][buffernum] != 1) {
							plot_pixel(dx + x, dy + y, 0xFFFF); // Draw pixel in white
						}
						// Update the mouse clear arrays with new positions
						if (x == 0 && (pixelData[dx + x][dy + y][buffernum] != 1)) {
							mouseClearY[buffernum][y] = dy + y;
						}
					}
					mouseClearX[buffernum][x] = dx + x;
				}
			}



			// Swap buffers
				
			if (buffernum==1){
				buffernum=0;
			}
			else{
				buffernum=1;
				}

          wait_for_vsync(); // Wait for vertical synchronization
				
			
          pixel_buffer_start = *(pixel_ctrl_ptr + 1); // new back buffe

            if ((byte2 == (char)0xAA) && (byte3 == (char)0x00)) {
			
                // Mouse inserted, initialize sending of data
                *PS2_ptr = 0xF4;
            }
		}
    }
}


/*************************************************************************************
mouse functions
*************************************************************************************/
void plot_pixel(int x, int y, short int line_color)
{
    volatile short int *one_pixel_address;
    one_pixel_address = (short int *)(pixel_buffer_start + (y << 10) + (x << 1));
    *one_pixel_address = line_color;
}

void wait_for_vsync()
{
    volatile int *pixel_ctrl_ptr = (int *)0xFF203020; // Base address
    int status;
    *pixel_ctrl_ptr = 1; // Start the synchronization process
    status = *(pixel_ctrl_ptr + 3); // Read the status register
    while ((status & 0x01) != 0) // Polling loop waiting for S bit to go to 0
    {
        status = *(pixel_ctrl_ptr + 3);
    } // Loop/function exits when status bit goes to 0
}

void clear_screen(){

    //initialize variables to iterate through the pixels
    int x;
	int y;
	
    //go over each pixel in the vga display and set the colour of the pixel to black
    for (x = 0; x < 320; x++) {
		for (y = 0; y < 240; y++) {
			plot_pixel(x, y, 0x0000);	
		}
	}

}
//need leave trail functions
//double buffer array, one loop that clears and one loop that adapts it
	
	
void clearpixel(int x,int y){
	plot_pixel(x,y,0x0000);
	pixelData[x][y][buffernum] = 0x0000;
}
